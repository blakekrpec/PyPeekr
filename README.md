# pypi_monitor
Tools to use a raspberry + display as a computer stat monitoring screen. 

The project is designed to have a server that hosts the computer stats over a local network. A client then grabs this data and presents it in a GUI on. 

Clone the project
```
git clone git@github.com:blakekrpec/pypi_monitor.git
```

### Server
[OpenHardwareMonitor](https://github.com/hexagon-oss/openhardwaremonitor) project as the server on Windows to host the pc information over the web. Future work aims to implement a Linux server as well, although this will likely be a custom implementation that mimics the data structure hosted by OpenHardwareMonitor.

To install OpenHardwareMonitor, grab the latest release [here](https://github.com/hexagon-oss/openhardwaremonitor/releases). Then follow the setup guide to complete installation. The http endpoints available are "/api/available" (returns "true" or an error if not), "/api/version" (returns the version of the server), "/api/rootnode" (returns a json with the sensor tree and all the values), "/api/nodes/{NodeId}" (returns a json with just the information for the given node).

Launch OpenHardwareMonitor and make the following changes to settings:

    Enable run on startup
    Enable web server
    Enable remote access for the web server

### Client 
The client will be written in python and will listen for data from server, and send it to the gui to be displayed. 

### GUI
The gui is written in python with Qt. It spawns a client to listen to data from server, and displays it in the gui.

The gui, and client live in the pypi_monitor pip package. The linux_setup.sh script included will create a python virtual environment for you, and install pypi_monitor in it.

#### Linux Setup
```
./linux_setup.sh
```
Source the python virtual environment
```
source .pypi_monitor/bin/activate
```
Start the client GUI
```
gui
```

#### Windows Setup

create venv
```
python -m venv .pypi_monitor
```
source venv
```
.\pypi_monitor\Scripts\activate
```
install pypi_monitor 
```
pip install -e .\pypi_monitor
```
run code 
```
gui
```

Current design:

- All python files in pypi_monitor should abide by Flake8 formatting guidelines. The linter should be run before all commits are made. Run the linter with `lint_pypi` from within the sourced .pypi_monitor vent. Tools like pylint should also be used to check for bad practices (the pylint extension in VSCode is very useful), but it is not required commits satisfy all concerns generated by pylint (or similar tools). It is required that all commits return no concerns when running `lint_pypi`.  

- Client will be a RasPi on the LAN with a systemctl service to run the gui on startup.

- Server
    - On Linux, we will need to write our own server, or get the OpenHardwareMonitor.exe to run on Linux.
    - On Windows, the OpenHardwareMonitor REST API will be used. We should consider adding an abstraction layer that takes info from OpenHardwareMonitor and then makes it more portable, currently there is a ton of info and really we may only want CPU and GPU. This will also standardize the input data structure into our client which would make the GUI agnostic of OpenHardwareMonitor (Windows) or our own server (Linux).  

- Done: 
    - Files separated for readability 
    - Settings functionality done (save and reset)
    - Settings button added to open settings dialog
    - Settings dialog has file and view tabs 
    - View tab added pick color ability 
    - View tab added displays button for displays dialog
    - Displays dialog done, has cpu and gpu tab
    - CPU and GPU tabs fleshed out, and now update the global settings in memory when interacted with.  
    - Added "gui" command with poetry to run the gui easily.
    - Added a check to make sure pip is up to date. 
    - Made "dark mode the default".
    - Moved to Qt6.
    - Create the pane manager class. Laid out the PaneController class. 
    - Display enable buttons text now toggle between enable and disable depending on button state. 
    - Add a resize event to the display pages so that actual stat buttons are half size.
    - Cleaned up Styling to new default. 
    - Pane Controller is implemented. 
    - Started laying out client scripts. 
    - Added ip as a setting, and allow the user to change it. 
    - Moved settings files out of the git repo to hide user ip addr from git. 
    - Made the above move of settings work on windows. 
    - Added port option to the settings so user can change it. 
    - Save IP Address button now writes IP settings to settings.yaml.
    - Added the stats (min, max, avg) to the panes.
    - Added a warning prompt when resetting that requires user to confirm before resetting. 
    - Added a slider for the user to change update rate in seconds. 
    - Fixed bug where eventResize was creating panes behind the settings button. 
        - Issue was resizeEvent was called on startup (which calls update_settings), and causing a race condition with the MainWindow__ init __  call of update_settings(). To fix added a delay where resizeEvent is ignored until the GUI has been up for 0.5 seconds. Should probably find a better way to do this. 
    - Fixed bug where on startup saw: "QLayout: Attempting to add QLayout "" to FileSettingsPage "", which already has a layout". Fixed because "self.slider_layout = QHBoxLayout(self)" needed to be "self.slider_layout = QHBoxLayout()" since self here is the FileSettingsPage QWidget, which is not what we were trying to apply self.slider_layout to. 
    - Python files now formatted to Flake8 formatting guidelines, and will continue to do so from now on. 
    - Added pause button to stop and start client threads. Also removed is_running from settings. Seemed unnecessary as the client should always start up on init, negating the need to save a false value for is_running. 
    - Added command to run the linter.
    - Added linux server, and poetry command to run it.
    - Linux server now also hosts, min, max, and avg values. The Windows client data dumper should structure things in a similar fashion so that the GUI can expect a common stat/data structure. 
    - Moved the logic to maintain min, max, and avg stats into the client, to separate from server. This will likely be more similar to how Windows data will need to be read, organized, and stored. 
    - Added a reset button. 
    - Linux client is now working and listening to linux server. 

- Next:
    - Pause isn't working. 
    - Make sure all values stat values are limited to only 1 dec place. 
    - Finish linux server to display data in the actual gui instead of just printing. 
        - Tried to do this. Calling udpate_panes() form client is causing: QObject::setParent: Cannot set parent, new parent is in a different thread.
    - Finish implementing windows client to read and store data.
    - Change the PaneController to interact with the client and print data as made available. 
    - Go change name util/utilzn/utilization to load throughout the project.
    - Add a setting for global font color. 
    - Add a logger to log errors and progress. Then add a button in settings where the user can print/view the log.

- Bugs: